isShowAllSensors = true
# attach observers for when data is added or changed
redraw = (metric) ->
  drawHeatMap '.heatmap', metric
  drawCircles $('#contrast_circle')
  #combineCanvas();
  return

# remap data into an array of 3-tuples (x,y,v)

regenData = (metric) ->
  tuples = []
  for id of locations
    if id.length > 8 or isShowAllSensors
      v = if id of data then parseFloat(data[id][metric]) else Math.random() * max
      t =
        x: locations[id][0]
        y: locations[id][1]
        value: v
      # console.log('REGEN: id=%s, metric=%s, tuple=%o', id, metric, t);
      tuples.push t
  tuples

# draw the floorplan

drawFloorPlan = (layer, src) ->
  plan = new Image
  plan.src = src

  plan.onload = ->
    canvas = layer
    ctx = canvas[0].getContext('2d')
    ctx.globalAlpha = 0.3
    ctx.drawImage plan, 50, 0, 1000, 1000 * plan.height / plan.width
    ctx.globalAlpha = 1.0
    return

  return

#draw the heatmap

drawHeatMap = (layer_name, metric) ->
  if `heatmap == undefined`
    console.log 'creating heatmap...'
    `heatmap = h337.create({
        container: document.querySelector(layer_name),
        gradient: {
            0.2: 'cyan',
            0.4: 'yellow',
            0.6: 'orange',
            1: 'red'
        },
        radius: 11,
        maxOpacity: 1,
        minOpacity: 0.6,
        blur: 0.5
    })`
  heat_data =
    max: max
    min: 10
    data: regenData(metric)
  # console.log("DATA: %o", heat_data );
  heatmap.setData heat_data
  heatmap.repaint()
  return

#draw the contrasting circles

drawCircles = (layer) ->
  canvas = layer
  ctx = canvas[0].getContext('2d')
  radius = 2
  for id of locations
    if id.length > 8 or isShowAllSensors
      ctx.beginPath()
      #open an svg path
      ctx.arc locations[id][0], locations[id][1], radius, 0, 2 * Math.PI, false
      #define arc
      ctx.closePath()
      #close the path
      # TODO: colour by sensor state
      ctx.fillStyle = 'blue'
      #define fill color
      ctx.fill()
  #fill the path
  #console.log(ctx);
  return


Template.sensor_list.helpers sensors: ->
  return Sensors.find()
  Meteor.call 'findSensors', {}, (e, r) ->
    console.log 'findSensors e:', e
    return
  return
metric = 'temp'

Template.sensor_list.rendered = ->
  drawFloorPlan $('#floorplan'), 'images/floorplan.svg'
  redraw metric
  return

# attach observers for when data is added or changed
Sensors.find().observe
  added: (datum) ->
# console.log('sensor %s added() %o', datum._id, datum);
# lookup location if not exist; use Session?
    if !datum._id of locations
# TODO location[_id] = []
    else
    data[datum._id] = datum
    redraw metric
    return
  changed: (datum) ->
# console.log('sensor %s changed() %o', datum._id, datum);
    redraw metric
    return
# helper functions
Template.sensor_item.helpers description: (id) ->
  if id of locations then locations[id][2] else '-'
max = 45
heatmap = `undefined`

# ---
# generated by js2coffee 2.1.0