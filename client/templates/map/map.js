// Generated by CoffeeScript 1.10.0
(function() {
  var drawCircles, drawFloorPlan, drawHeatMap, heatmap, isShowAllSensors, max, metric, redraw, regenData;

  isShowAllSensors = true;

  redraw = function(metric) {
    drawHeatMap('.heatmap', metric);
    drawCircles($('#contrast_circle'));
  };

  regenData = function(metric) {
    var id, t, tuples, v;
    tuples = [];
    for (id in locations) {
      if (id.length > 8 || isShowAllSensors) {
        v = id in data ? parseFloat(data[id][metric]) : Math.random() * max;
        t = {
          x: locations[id][0],
          y: locations[id][1],
          value: v
        };
        tuples.push(t);
      }
    }
    return tuples;
  };

  drawFloorPlan = function(layer, src) {
    var plan;
    plan = new Image;
    plan.src = src;
    plan.onload = function() {
      var canvas, ctx;
      canvas = layer;
      ctx = canvas[0].getContext('2d');
      ctx.globalAlpha = 0.3;
      ctx.drawImage(plan, 50, 0, 1000, 1000 * plan.height / plan.width);
      ctx.globalAlpha = 1.0;
    };
  };

  drawHeatMap = function(layer_name, metric) {
    var heat_data;
    if (heatmap == undefined) {
      console.log('creating heatmap...');
      heatmap = h337.create({
        container: document.querySelector(layer_name),
        gradient: {
            0.2: 'cyan',
            0.4: 'yellow',
            0.6: 'orange',
            1: 'red'
        },
        radius: 11,
        maxOpacity: 1,
        minOpacity: 0.6,
        blur: 0.5
    });
    }
    heat_data = {
      max: max,
      min: 10,
      data: regenData(metric)
    };
    heatmap.setData(heat_data);
    heatmap.repaint();
  };

  drawCircles = function(layer) {
    var canvas, ctx, id, radius;
    canvas = layer;
    ctx = canvas[0].getContext('2d');
    radius = 2;
    for (id in locations) {
      if (id.length > 8 || isShowAllSensors) {
        ctx.beginPath();
        ctx.arc(locations[id][0], locations[id][1], radius, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.fillStyle = 'blue';
        ctx.fill();
      }
    }
  };

  Template.sensor_list.helpers({
    sensors: function() {
      return Sensors.find();
      Meteor.call('findSensors', {}, function(e, r) {
        console.log('findSensors e:', e);
      });
    }
  });

  metric = 'temp';

  Template.sensor_list.rendered = function() {
    drawFloorPlan($('#floorplan'), 'images/floorplan.svg');
    redraw(metric);
  };

  Sensors.find().observe({
    added: function(datum) {
      if (!datum._id in locations) {

      } else {

      }
      data[datum._id] = datum;
      redraw(metric);
    },
    changed: function(datum) {
      redraw(metric);
    }
  });

  Template.sensor_item.helpers({
    description: function(id) {
      if (id in locations) {
        return locations[id][2];
      } else {
        return '-';
      }
    }
  });

  max = 45;

  heatmap = undefined;

}).call(this);

//# sourceMappingURL=map.js.map
